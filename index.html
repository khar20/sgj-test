<!DOCTYPE html>
<html>

<head>
    <title>Gravitas</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0c0c1a;
        }

        canvas {
            display: block;
            cursor: none;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 20px;
            text-shadow: 2px 2px 4px #000;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFF;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 36px;
            text-shadow: 3px 3px 6px #000;
            display: none;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="hud">
        <div>Score: <span id="score">0</span></div>
        <div>Speed: <span id="speed">0.00</span></div>
    </div>
    <div id="message"></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const speedElement = document.getElementById('speed');
        const messageElement = document.getElementById('message');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game State
        let score = 0;
        const G = 0.5;
        const maxSpeed = 15;
        let isGameOver = false;
        const baseScrollSpeed = 2.0;

        const player = {
            x: 0,
            y: canvas.height / 2,
            radius: 10,
            screenX: window.innerWidth * 0.25,
            velocityX: baseScrollSpeed, // horizontal scroll speed
            velocityY: 0,               // vertical speed
            thrust: 1,
            turnSpeed: 0.05,
            angle: 0
        };

        let planets = [], goals = [], particles = [], floatingTexts = [], trajectory = [];

        // Level Generation
        let lastSpawnX = 0;
        const spawnChunkWidth = 800;
        const planetColors = ['#4a4e69', '#9a8c98', '#c9ada7', '#6d597a', '#b5838d'];

        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

        window.addEventListener('keydown', (e) => { if (e.code in keys) { e.preventDefault(); keys[e.code] = true; } });
        window.addEventListener('keyup', (e) => { if (e.code in keys) { e.preventDefault(); keys[e.code] = false; } });

        // Core Logic
        function resetGame() {
            player.x = 0;
            player.y = canvas.height / 2;
            player.velocityX = baseScrollSpeed;
            player.velocityY = 0;
            player.angle = 0;
            score = 0;
            scoreElement.textContent = score;

            planets = [], goals = [], particles = [], floatingTexts = [];
            lastSpawnX = 0;

            isGameOver = false;
            showMessage("Arrow Keys to Move<br>UP to Thrust", 2500);
        }

        function update() {
            if (isGameOver) {
                updateParticles();
                return;
            }

            const playerWorldX = player.x + player.screenX;

            handleInput();
            updatePlayerPosition(playerWorldX);
            checkCollisions(playerWorldX);
            manageWorldGeneration();
            calculateTrajectory(playerWorldX);

            updateParticles();
            updateFloatingTexts();
            speedElement.textContent = Math.hypot(player.velocityX, player.velocityY).toFixed(2);
        }

        function handleInput() {
            if (keys.ArrowLeft) player.angle -= player.turnSpeed;
            if (keys.ArrowRight) player.angle += player.turnSpeed;

            if (keys.ArrowUp) {
                player.velocityX += Math.cos(player.angle) * player.thrust;
                player.velocityY += Math.sin(player.angle) * player.thrust;
                createThrustParticles();
            }
            if (keys.ArrowDown) {
                player.velocityX -= Math.cos(player.angle) * player.thrust / 2;
                player.velocityY -= Math.sin(player.angle) * player.thrust / 2;
            }
        }

        function updatePlayerPosition(playerWorldX) {
            // Apply Gravity
            planets.forEach(p => {
                const dx = p.x - playerWorldX;
                const dy = p.y - player.y;
                const distanceSq = dx * dx + dy * dy;

                if (distanceSq > (p.radius * p.radius)) {
                    const distance = Math.sqrt(distanceSq);
                    const force = (G * p.mass) / distanceSq;
                    player.velocityX += (force * dx) / distance;
                    player.velocityY += (force * dy) / distance;
                }
            });

            // Speed Limit
            const speed = Math.hypot(player.velocityX, player.velocityY);
            if (speed > maxSpeed) {
                player.velocityX = (player.velocityX / speed) * maxSpeed;
                player.velocityY = (player.velocityY / speed) * maxSpeed;
            }

            // Scrolls forward
            if (player.velocityX < 1.0) {
                player.velocityX = 1.0;
            }

            // Update Position
            player.x += player.velocityX;
            player.y += player.velocityY;
        }

        function checkCollisions(playerWorldX) {
            if (player.y - player.radius < 0 || player.y + player.radius > canvas.height) {
                triggerGameOver(); return;
            }
            for (const p of planets) {
                if (Math.hypot(p.x - playerWorldX, p.y - player.y) < player.radius + p.radius) {
                    triggerGameOver(); return;
                }
            }
            goals.forEach((g, index) => {
                if (Math.hypot(g.x - playerWorldX, g.y - player.y) < player.radius + g.radius) {
                    score += 10;
                    scoreElement.textContent = score;
                    floatingTexts.push({ text: "+10", x: g.x, y: g.y, life: 60, opacity: 1 });
                    createExplosion(g.x, g.y, 'gold', 15);
                    goals.splice(index, 1);
                }
            });
        }

        function manageWorldGeneration() {
            if (player.x + canvas.width > lastSpawnX) {
                const spawnStart = lastSpawnX + spawnChunkWidth;
                const numPlanets = Math.random() > 0.6 ? 2 : 1;
                for (let i = 0; i < numPlanets; i++) spawnObject('planet', spawnStart);
                for (let i = 0; i < 2; i++) spawnObject('goal', spawnStart);
                lastSpawnX += spawnChunkWidth;
            }
            const cullX = player.x - 200; // left edge of the screen
            planets = planets.filter(p => p.x + p.radius > cullX);
            goals = goals.filter(g => g.x + g.radius > cullX);
        }

        function spawnObject(type, spawnAreaX) {
            let x, y, radius, attempts = 0;
            while (attempts < 20) {
                let isValidPosition = true;
                x = spawnAreaX + Math.random() * spawnChunkWidth;
                y = Math.random() * canvas.height;
                radius = (type === 'planet') ? Math.random() * 40 + 25 : 15;

                const allObjects = [...planets, ...goals];
                for (const obj of allObjects) {
                    if (Math.hypot(obj.x - x, obj.y - y) < obj.radius + radius + 50) {
                        isValidPosition = false; break;
                    }
                }
                if (isValidPosition) {
                    if (type === 'planet') {
                        planets.push({ x, y, radius, mass: radius * 500, color: planetColors[Math.floor(Math.random() * planetColors.length)] });
                    } else {
                        goals.push({ x, y, radius });
                    }
                    return;
                }
                attempts++;
            }
        }

        function calculateTrajectory(playerWorldX) {
            trajectory = [];
            let ghost = { x: playerWorldX, y: player.y, vx: player.velocityX, vy: player.velocityY };

            for (let i = 0; i < 100; i++) {
                planets.forEach(p => {
                    const dx = p.x - ghost.x; const dy = p.y - ghost.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > (p.radius * p.radius)) {
                        const dist = Math.sqrt(distSq);
                        const force = (G * p.mass) / distSq;
                        ghost.vx += (force * dx) / dist; ghost.vy += (force * dy) / dist;
                    }
                });
                ghost.x += ghost.vx; ghost.y += ghost.vy;
                if (i % 5 === 0) trajectory.push({ x: ghost.x, y: ghost.y });
            }
        }

        function triggerGameOver() {
            if (isGameOver) return;
            isGameOver = true;
            const playerWorldX = player.x + player.screenX;
            createExplosion(playerWorldX, player.y, 'cyan', 50);
            setTimeout(resetGame, 2000);
        }

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Camera 
            ctx.save();
            ctx.translate(-player.x, 0);

            drawPhysicsVisuals();
            drawObjects();
            if (!isGameOver) drawPlayer();
            drawEffects();

            ctx.restore(); // restore camera
        }

        function drawPhysicsVisuals() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            planets.forEach(p => {
                const wellRadius = p.radius * (Math.sqrt(p.mass * G) / 40);
                for (let i = 1; i <= 10; i++) {
                    ctx.beginPath();
                    const r = wellRadius * (i / 10);
                    ctx.arc(p.x, p.y, p.radius + r, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (trajectory.length > 0) ctx.moveTo(trajectory[0].x, trajectory[0].y);
            trajectory.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        }

        function drawObjects() {
            planets.forEach(p => {
                const gradient = ctx.createRadialGradient(p.x - p.radius * 0.3, p.y - p.radius * 0.3, p.radius * 0.1, p.x, p.y, p.radius);
                gradient.addColorStop(0, p.color); gradient.addColorStop(1, '#000');
                ctx.fillStyle = gradient;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
            });
            goals.forEach(g => {
                const pulse = Math.sin(Date.now() * 0.005) * 5;
                ctx.fillStyle = 'gold';
                ctx.beginPath(); ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = `rgba(255, 215, 0, 0.5)`;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(g.x, g.y, g.radius + pulse, 0, Math.PI * 2); ctx.stroke();
            });
        }

        function drawPlayer() {
            const playerDrawX = player.x + player.screenX;
            ctx.save();
            ctx.translate(playerDrawX, player.y);
            ctx.rotate(player.angle);
            ctx.fillStyle = 'cyan';
            ctx.beginPath();
            ctx.moveTo(15, 0); ctx.lineTo(-10, -8); ctx.lineTo(-10, 8);
            ctx.closePath(); ctx.fill();
            ctx.restore();
        }

        function drawEffects() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius * (p.life / p.startLife), 0, Math.PI * 2); ctx.fill();
            });
            floatingTexts.forEach(t => {
                ctx.font = '20px Consolas';
                ctx.fillStyle = `rgba(255, 255, 255, ${t.opacity})`;
                ctx.fillText(t.text, t.x, t.y);
            });
        }

        function createThrustParticles() {
            const playerWorldX = player.x + player.screenX;
            const angle = player.angle + Math.PI + (Math.random() - 0.5) * 0.4;
            const speed = 2 + Math.random();
            particles.push({
                x: playerWorldX, y: player.y,
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                life: 30, startLife: 30, radius: Math.random() * 2 + 1, color: 'cyan'
            });
        }

        function createExplosion(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 6 + 1;
                const life = 60 + Math.random() * 30;
                particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, startLife: life, radius: Math.random() * 3 + 1, color });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const t = floatingTexts[i];
                t.y -= 0.5; t.life--;
                t.opacity = t.life / 60;
                if (t.life <= 0) floatingTexts.splice(i, 1);
            }
        }

        function showMessage(html, duration) {
            messageElement.innerHTML = html;
            messageElement.style.opacity = 1;
            setTimeout(() => { messageElement.style.opacity = 0; }, duration - 500);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        resetGame();
        gameLoop();
    </script>
</body>

</html>